속성 값으로 전달되는 함수를 의존성 배열에 넣는 순간, 그 함수는 부모 컴포넌트에서 useCallback 등을 사용해서 자주 변경되지 않도록 신경써서 관리해야 함

의존성 배열을 입력하지 않는 대신,
부수효과 함수 내에서 실행 시점을 조절할 수 있음 (`1.js`)

이렇게 함수의 실행 시점을 의존성 배열로 관리하지 않고,
부수효과 함수 내에서 처리하면, 부수 효과 함수 내에 참조되는 모든 변수는 최신화된 값을 참조하므로 안심할 수 있음

따라서 useCallback같은 함수를 사용하지 않아도 됨

---

이전 상태값을 다음 상태값으로 변경하기 위해,
상태값을 의존성 배열에 추가하는 경우가 있음

이럴 때는 `2`보다는 `3`처럼 상태값 변경 함수에 함수를 입력하면 됨
해당 함수의 매개변수로 이전 상태값이 들어오기 때문.

---

여러 상태값을 참조하면서 값을 변경할 때는 `4`보다는 `5`처럼 useReducer 훅을 사용하는 것이 좋음
dispatch 함수는 변하지 않는 값이므로, 의존성 배열로 빈 배열을 입력했다 생각할 수 있다.

값이 변경되는 로직은 reducer에서 작성

useReducer를 사용하면 상태값의 관리와 재사용이 편함

---

의존성 배열을 해결법을 모를때가 생길 수 있음.

특히 `6`처럼 속성값으로 전달되는 함수는 자주 변경되는 경우가 많음
이런 함수는 내용은 그대로인데 렌더링할 때마다 변경되는 경우가 많음

마땅한 해결책을 모르겠다면 `7`처럼 useRef 훅으로 해결할 수도 있음
렌더링이 될 때마다 ref 객체에 onclick 함수를 넣어줌
그리고 원래 사용하려던 곳에서 ref 객체를 이용해 함수를 호출하는 방식
의존성 배열에 작성하지 않아도 되지만, 이를 해결하기 위해 불필요한 코드와 연산 작업이 추가됨

의존성 배열의 규칙을 지키기 위해 어쩔 수 없음, 이런 부분이 리액트 훅의 단점

---

ref 객체는 `8`처럼 컴포넌트 내부에서 직접 변경할 수 있다고 생각하지만 한 가지 문제가 있음

부수효과 함수에서 ref 객체를 수정하는 이유는, 나중에 도입될 리액트의 concurrent mode 때문

concurrent mode가 동작할 때는 컴포넌트 함수가 실행 됐다고 하더라도 중간에 렌더링이 취소될 수 있음
렌더링은 취소 됐는데 ref 객체는 잘못된 값이 저장될 수 있으므로 컴포넌트 함수에서 직접 수정하면 안됨

단, concurent mode가 동작하지 않는 리액트 버전에서는 문제되지 않음
나중을 위해 `7`처럼 작성하는 것이 좋음
