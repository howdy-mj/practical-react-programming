훅 배우기

상태값 변경을 왜 비동기 배치(batch)로 처리할까?

- 만약 리액트가 상태값 변경 함수를 동기로 처리하면 하나의 상태값이 변경될 때마다 화면을 다시 그리기 때문에 성능 이슈가 생길 수 있음.
- 만약 상태값을 동기로 처리하고 매번 화면을 다시 그리지 않는다면, UI 데이터와 화면간의 불일치가 발생해서 혼란스러울 수 있음
- 제대로 해결하려면 상태값 변경 함수에 함수를 입력해야 함 (ex. setCount(v => v+ 1))
- 함수로 입력하면, 처리되기 직전의 상태값을 매개변수로 받기 때문에 원하는대로 동작

concurrent mode의 리액트에서는 외부에서 처리되는 이벤트 함수도 배치로 처리될 예정이라고 함

---

`1-batch.js`: 'unstable_batchedUpdates'를 통해 렌더를 한번만

`3-multi.js`: 여러 개의 상태값 관리는 useState에서 객체로 관리 가능하지만, useReducer가 더 적합

`4-useEffect`: 순수 함수의 장점을 살리기 위해 부수효과를 렌더가 되고 나서 비동기로 호출하는 것

`5-useEffect-api`: 의존성 배열에 넣어야 할 것, 지역 변수나 함수가 useEffect안에 있다면 이 역시 작성해야 하지만, 자주 변경되는 함수는 useCallback으로 처리하는 것이 좋음

`6-useEffect-event`: 부수효과 함수가 반환하는 값

``
